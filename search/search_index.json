{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Isotopes \u00b6 Getting the most out of AWS SimpleDB \u00b6 A serverless, typed and super lightweight object store that enables storage, indexing and querying of JSON documents in AWS SimpleDB using SQL queries. Isotopes is just perfect for small to medium-sized datasets, especially for indexing metadata from other AWS services for flexible querying. It can easily be run from within AWS Lambda and reduces the boilerplate that is necessary to interface with SimpleDB to an absolute minimum. Quick start \u00b6 npm install isotopes aws-sdk In your project: import { Isotope } from \"isotopes\" const isotope = new Isotope < T > ({ domain : \"<domain>\" , key : \"<keyof T>\" }) For detailed instructions see the getting started guide and the API reference guide .","title":"About"},{"location":"#isotopes","text":"","title":"Isotopes"},{"location":"#getting-the-most-out-of-aws-simpledb","text":"A serverless, typed and super lightweight object store that enables storage, indexing and querying of JSON documents in AWS SimpleDB using SQL queries. Isotopes is just perfect for small to medium-sized datasets, especially for indexing metadata from other AWS services for flexible querying. It can easily be run from within AWS Lambda and reduces the boilerplate that is necessary to interface with SimpleDB to an absolute minimum.","title":"Getting the most out of AWS SimpleDB"},{"location":"#quick-start","text":"npm install isotopes aws-sdk In your project: import { Isotope } from \"isotopes\" const isotope = new Isotope < T > ({ domain : \"<domain>\" , key : \"<keyof T>\" }) For detailed instructions see the getting started guide and the API reference guide .","title":"Quick start"},{"location":"contributing/","text":"Contributing \u00b6 Interested in contributing to this project? Want to report a bug? Before you do, please read the following guidelines. Submission context \u00b6 Got a question or problem? \u00b6 For quick questions there's no need to open an issue as you can reach us on gitter.im . Found a bug? \u00b6 If you found a bug, you can help us by submitting an issue to the issue tracker in our GitHub repository. Even better, you can submit a pull request with a fix. However, before doing so, please read the submission guidelines . Missing a feature? \u00b6 You can request a new feature by submitting an issue to our GitHub Repository. If you would like to implement a new feature, please submit an issue with a proposal for your work first, to be sure that it is of use for everyone. Please consider what kind of change it is: For a major feature , first open an issue and outline your proposal so that it can be discussed. This will also allow us to better coordinate our efforts, prevent duplication of work and help you to craft the change so that it is successfully accepted into the project. Small features and bugs can be crafted and directly submitted as a pull request (PR). However, there is no guarantee that your feature will make it into the master, as it's always a matter of opinion whether if benefits the overall functionality of this project. Submission guidelines \u00b6 Submitting an issue \u00b6 Before you submit an issue, please search the issue tracker. Maybe the problem you are encountering is already known and the discussion might inform you of workarounds readily available. We want to address all the issues as soon as possible, but before fixing a bug we first need to reproduce and confirm it. In order to reproduce bugs we will systematically ask you to provide a minimal reproduction scenario using the custom issue template. Please stick to the issue template. Unfortunately we are not able to investigate / fix bugs without a minimal reproduction scenario, so if we don't hear back from you we may close the issue. Submitting a pull request \u00b6 Search GitHub for an open or closed PR that relates to your submission. You don't want to duplicate effort. If you do not find a related issue or PR, go ahead. Fork the project, make your changes in a separate git branch and add descriptive messages to your commits. Push your branch to GitHub and send a PR to isotopes:master . If we suggest changes, rebase your branch and push the changes to your GitHub repository, which will automatically update your PR. After your PR is merged, you can safely delete your branch and pull the changes from the main (upstream) repository.","title":"Contributing"},{"location":"contributing/#contributing","text":"Interested in contributing to this project? Want to report a bug? Before you do, please read the following guidelines.","title":"Contributing"},{"location":"contributing/#submission-context","text":"","title":"Submission context"},{"location":"contributing/#got-a-question-or-problem","text":"For quick questions there's no need to open an issue as you can reach us on gitter.im .","title":"Got a question or problem?"},{"location":"contributing/#found-a-bug","text":"If you found a bug, you can help us by submitting an issue to the issue tracker in our GitHub repository. Even better, you can submit a pull request with a fix. However, before doing so, please read the submission guidelines .","title":"Found a bug?"},{"location":"contributing/#missing-a-feature","text":"You can request a new feature by submitting an issue to our GitHub Repository. If you would like to implement a new feature, please submit an issue with a proposal for your work first, to be sure that it is of use for everyone. Please consider what kind of change it is: For a major feature , first open an issue and outline your proposal so that it can be discussed. This will also allow us to better coordinate our efforts, prevent duplication of work and help you to craft the change so that it is successfully accepted into the project. Small features and bugs can be crafted and directly submitted as a pull request (PR). However, there is no guarantee that your feature will make it into the master, as it's always a matter of opinion whether if benefits the overall functionality of this project.","title":"Missing a feature?"},{"location":"contributing/#submission-guidelines","text":"","title":"Submission guidelines"},{"location":"contributing/#submitting-an-issue","text":"Before you submit an issue, please search the issue tracker. Maybe the problem you are encountering is already known and the discussion might inform you of workarounds readily available. We want to address all the issues as soon as possible, but before fixing a bug we first need to reproduce and confirm it. In order to reproduce bugs we will systematically ask you to provide a minimal reproduction scenario using the custom issue template. Please stick to the issue template. Unfortunately we are not able to investigate / fix bugs without a minimal reproduction scenario, so if we don't hear back from you we may close the issue.","title":"Submitting an issue"},{"location":"contributing/#submitting-a-pull-request","text":"Search GitHub for an open or closed PR that relates to your submission. You don't want to duplicate effort. If you do not find a related issue or PR, go ahead. Fork the project, make your changes in a separate git branch and add descriptive messages to your commits. Push your branch to GitHub and send a PR to isotopes:master . If we suggest changes, rebase your branch and push the changes to your GitHub repository, which will automatically update your PR. After your PR is merged, you can safely delete your branch and pull the changes from the main (upstream) repository.","title":"Submitting a pull request"},{"location":"format/","text":"Format \u00b6 Encoding \u00b6 The encoding can be set when creating the isotope, e.g.: const isotope = new Isotope < T > ({ format : { encoding : \"text\" }, domain : \"<domain>\" , key : \"<keyof T>\" }) options.format.encoding: \"json\" All values are JSON-encoded, which means that strings are double-quoted, whereas numbers and booleans are written literally: { \"Name\" : \"example\" , \"Attributes\" : [ { \"Name\" : \"active\" , \"Value\" : \"true\" }, { \"Name\" : \"props.image\" , \"Value\" : \"\\\"busybox\\\"\" }, { \"Name\" : \"props.cpus\" , \"Value\" : \"2\" }, { \"Name\" : \"props.memory\" , \"Value\" : \"2048\" }, { \"Name\" : \"tags[]\" , \"Value\" : \"\\\"TAG_1\\\"\" }, { \"Name\" : \"tags[]\" , \"Value\" : \"\\\"TAG_2\\\"\" } ] } If you don't plan to use the SimpleDB domain from a non- Isotope client, you should always stick with JSON-encoding because it is more safe than text encoding and comes with no limitations. options.format.encoding: \"text\" Isotopes provides the ability to use an alternate encoding and store strings as literals so they are written without quotes: { \"Name\" : \"example\" , \"Attributes\" : [ { \"Name\" : \"active\" , \"Value\" : \"true\" }, { \"Name\" : \"props.image\" , \"Value\" : \"busybox\" }, { \"Name\" : \"props.cpus\" , \"Value\" : \"2\" }, { \"Name\" : \"props.memory\" , \"Value\" : \"2048\" }, { \"Name\" : \"tags[]\" , \"Value\" : \"TAG_1\" }, { \"Name\" : \"tags[]\" , \"Value\" : \"TAG_2\" } ] } When decoding the data, we intercept JSON.parse assuming that we encountered a literal string if it fails to decode. It's a hack and yes, imposes some limitations: Numbers that are encoded as strings (e.g. house numbers, because they can exhibit values as 2A etc.) are interpreted as numbers when decoded with JSON.parse . Countermeasure : ensure that numbers are typed as numbers, or string fields contain at least one non-number character. If strings accidentally contain valid JSON, e.g. {} , the value is parsed as JSON and the field gets assigned that precise value. This also breaks type safety. Countermeasure : ensure that your strings are never valid JSON by prepending some character that makes JSON.parse fail. As enforcing as those restrictions may seem to be, it is often true that the properties and characteristics of the data are known a-priori and those special cases can be ruled out with great certainty. This also means that querying the data from other parts of your system gets easier as string values don't need to be enclosed into quotes (and don't start thinking about LIKE queries) which is far more user-friendly. Flattening \u00b6 Isotopes enables the storage of nested JSON objects within SimpleDB which itself is a key-value store with the ability to query using SQL expressions. In order to be compatible with SimpleDB, objects need to be flattened to match the key-value nature of SimpleDB. Objects \u00b6 Nested objects are flattened by concatenating the keys with . and associating the value of the nested object's key with the concatenated path, e.g.: { \"foo\" : { \"bar\" : \"baz\" } } becomes: { \"Name\" : \"foo.bar\" , \"Value\" : \"baz\" } Arrays \u00b6 There are two flavors for nested arrays, both with different use cases. Which flavor is used is actually controlled using the options.format.multiple option when creating the isotope: options.format.multiple = true (default) Array values are written as separate attributes . This is especially useful for arrays with primitive values ( string , number and boolean ) to enable indexing and queryability. Field names are suffixed with [] to indicate an array of values. However, note that SimpleDB doesn't guarantee order of attributes , so only use this if the order of the entries inside the array doesn't matter, e.g. for tagging: { \"tags\" : [ \"TAG_1\" , \"TAG_2\" ] } becomes: { \"Name\" : \"tags[]\" , \"Value\" : \"TAG_1\" } , { \"Name\" : \"tags[]\" , \"Value\" : \"TAG_2\" } options.format.multiple = false Arrays are written as a single attribute using \"json\" encoding. While this guarantees the order of array values, it is certainly not possible to query for separate values using SQL expressions as they are encoded in JSON syntax, e.g.: { \"tags\" : [ \"TAG_1\" , \"TAG_2\" ] } becomes: { \"Name\" : \"tags\" , \"Value\" : \"[\\\"TAG_1\\\", \\\"TAG_2\\\"]\" } Example \u00b6 Assume we want to persist the type specified in the getting started guide . When persisting an object of this type with multiple = true and \"text\" encoding, the flattened data that is persisted in SimpleDB will look like this: { \"Name\" : \"example\" , \"Attributes\" : [ { \"Name\" : \"active\" , \"Value\" : \"true\" }, { \"Name\" : \"props.image\" , \"Value\" : \"busybox\" }, { \"Name\" : \"props.cpus\" , \"Value\" : \"2\" }, { \"Name\" : \"props.memory\" , \"Value\" : \"2048\" }, { \"Name\" : \"tags[]\" , \"Value\" : \"TAG_1\" }, { \"Name\" : \"tags[]\" , \"Value\" : \"TAG_2\" } ] }","title":"Format"},{"location":"format/#format","text":"","title":"Format"},{"location":"format/#encoding","text":"The encoding can be set when creating the isotope, e.g.: const isotope = new Isotope < T > ({ format : { encoding : \"text\" }, domain : \"<domain>\" , key : \"<keyof T>\" }) options.format.encoding: \"json\" All values are JSON-encoded, which means that strings are double-quoted, whereas numbers and booleans are written literally: { \"Name\" : \"example\" , \"Attributes\" : [ { \"Name\" : \"active\" , \"Value\" : \"true\" }, { \"Name\" : \"props.image\" , \"Value\" : \"\\\"busybox\\\"\" }, { \"Name\" : \"props.cpus\" , \"Value\" : \"2\" }, { \"Name\" : \"props.memory\" , \"Value\" : \"2048\" }, { \"Name\" : \"tags[]\" , \"Value\" : \"\\\"TAG_1\\\"\" }, { \"Name\" : \"tags[]\" , \"Value\" : \"\\\"TAG_2\\\"\" } ] } If you don't plan to use the SimpleDB domain from a non- Isotope client, you should always stick with JSON-encoding because it is more safe than text encoding and comes with no limitations. options.format.encoding: \"text\" Isotopes provides the ability to use an alternate encoding and store strings as literals so they are written without quotes: { \"Name\" : \"example\" , \"Attributes\" : [ { \"Name\" : \"active\" , \"Value\" : \"true\" }, { \"Name\" : \"props.image\" , \"Value\" : \"busybox\" }, { \"Name\" : \"props.cpus\" , \"Value\" : \"2\" }, { \"Name\" : \"props.memory\" , \"Value\" : \"2048\" }, { \"Name\" : \"tags[]\" , \"Value\" : \"TAG_1\" }, { \"Name\" : \"tags[]\" , \"Value\" : \"TAG_2\" } ] } When decoding the data, we intercept JSON.parse assuming that we encountered a literal string if it fails to decode. It's a hack and yes, imposes some limitations: Numbers that are encoded as strings (e.g. house numbers, because they can exhibit values as 2A etc.) are interpreted as numbers when decoded with JSON.parse . Countermeasure : ensure that numbers are typed as numbers, or string fields contain at least one non-number character. If strings accidentally contain valid JSON, e.g. {} , the value is parsed as JSON and the field gets assigned that precise value. This also breaks type safety. Countermeasure : ensure that your strings are never valid JSON by prepending some character that makes JSON.parse fail. As enforcing as those restrictions may seem to be, it is often true that the properties and characteristics of the data are known a-priori and those special cases can be ruled out with great certainty. This also means that querying the data from other parts of your system gets easier as string values don't need to be enclosed into quotes (and don't start thinking about LIKE queries) which is far more user-friendly.","title":"Encoding"},{"location":"format/#flattening","text":"Isotopes enables the storage of nested JSON objects within SimpleDB which itself is a key-value store with the ability to query using SQL expressions. In order to be compatible with SimpleDB, objects need to be flattened to match the key-value nature of SimpleDB.","title":"Flattening"},{"location":"format/#objects","text":"Nested objects are flattened by concatenating the keys with . and associating the value of the nested object's key with the concatenated path, e.g.: { \"foo\" : { \"bar\" : \"baz\" } } becomes: { \"Name\" : \"foo.bar\" , \"Value\" : \"baz\" }","title":"Objects"},{"location":"format/#arrays","text":"There are two flavors for nested arrays, both with different use cases. Which flavor is used is actually controlled using the options.format.multiple option when creating the isotope: options.format.multiple = true (default) Array values are written as separate attributes . This is especially useful for arrays with primitive values ( string , number and boolean ) to enable indexing and queryability. Field names are suffixed with [] to indicate an array of values. However, note that SimpleDB doesn't guarantee order of attributes , so only use this if the order of the entries inside the array doesn't matter, e.g. for tagging: { \"tags\" : [ \"TAG_1\" , \"TAG_2\" ] } becomes: { \"Name\" : \"tags[]\" , \"Value\" : \"TAG_1\" } , { \"Name\" : \"tags[]\" , \"Value\" : \"TAG_2\" } options.format.multiple = false Arrays are written as a single attribute using \"json\" encoding. While this guarantees the order of array values, it is certainly not possible to query for separate values using SQL expressions as they are encoded in JSON syntax, e.g.: { \"tags\" : [ \"TAG_1\" , \"TAG_2\" ] } becomes: { \"Name\" : \"tags\" , \"Value\" : \"[\\\"TAG_1\\\", \\\"TAG_2\\\"]\" }","title":"Arrays"},{"location":"format/#example","text":"Assume we want to persist the type specified in the getting started guide . When persisting an object of this type with multiple = true and \"text\" encoding, the flattened data that is persisted in SimpleDB will look like this: { \"Name\" : \"example\" , \"Attributes\" : [ { \"Name\" : \"active\" , \"Value\" : \"true\" }, { \"Name\" : \"props.image\" , \"Value\" : \"busybox\" }, { \"Name\" : \"props.cpus\" , \"Value\" : \"2\" }, { \"Name\" : \"props.memory\" , \"Value\" : \"2048\" }, { \"Name\" : \"tags[]\" , \"Value\" : \"TAG_1\" }, { \"Name\" : \"tags[]\" , \"Value\" : \"TAG_2\" } ] }","title":"Example"},{"location":"getting-started/","text":"Getting started \u00b6 Installation \u00b6 Isotopes can be installed with npm : npm install isotopes aws-sdk TypeScript typings are provided as part of the package, so no need to install a separate package. The aws-sdk is listed as a peer dependency, so make sure it is installed. Note that when you run Isotopes from within AWS Lambda the SDK is already installed. Usage \u00b6 Isotopes = SimpleDB + TypeScript The following instructions are intended for usage with TypeScript. You can also use Isotopes from plain JavaScript by omitting all typings from the examples, but what would be the point? Learn TypeScript , it's awesome! First, import Isotopes into your project: import { Isotope } from \"isotopes\" Next, define a TypeScript interface for the data you want to store, e.g. a type for running a task on a cluster: export interface Task { id : string /* Unique identifier */ active : boolean /* Whether the task can be scheduled */ props : { image : string /* Docker image to use */ cpus : number /* Number of CPUs */ memory : number /* Reserved memory */ command? : string /* Command override */ }, tags : string [] /* Tags for categorization */ } Every type that is handled by Isotopes must contain a unique identifier which is used as an item name. The item name must be on the first level of the type to be stored, all other variables can be arbitrarily nested. Next, create an isotope for the type, e.g. for a SimpleDB domain named tasks : const tasks = new Isotope < Task > ({ domain : \"tasks\" , /* SimpleDB domain name */ key : \"id\" /* SimpleDB item name (primary key) */ }) Now, suppose we have the following item: const task : Task = { id : \"example\" , active : true , props : { image : \"busybox\" , cpus : 2 , memory : 2048 }, tags : [ \"TAG_1\" , \"TAG_2\" ] } We can persist, retrieve and delete items from the isotope by using a simple API, cleverly omitting all the boilerplate that is normally necessary for interfacing with SimpleDB. Create a domain \u00b6 Reference for Isotope.create If the SimpleDB domain doesn't exist, create it: await isotope . create () Persist an item \u00b6 Reference for Isotope.put Persisting an item is as simple as: await tasks . put ( task ) // => void Retrieve an item \u00b6 Reference for Isotope.get Retrieving an item by primary key (unique identifier, in our example id ): const task = await tasks . get ( \"example\" ) // => Task | undefined Delete an item \u00b6 Reference for Isotope.delete Delete an item by primary key: await tasks . delete ( \"example\" ) // => void Query a domain \u00b6 Reference for Isotope.select We can also build queries using a stripped-down version of the squel query builder interface: const expr = tasks . getQueryBuilder () . where ( \"`active` = ?\" , true ) . order ( \"`props.memory >= ?`\" , 2048 ) . limit ( 100 ) The query expression can then be used to perform a SELECT operation: await tasks . select ( expr ) Handling errors \u00b6 All methods except getQueryBuilder return Promises, so they are best to be used with ES7's async/await and wrapped in try/catch blocks for error handling purposes: try { await tasks . put ( task ) } catch ( err ) { /* Handle error */ }","title":"Getting started"},{"location":"getting-started/#getting-started","text":"","title":"Getting started"},{"location":"getting-started/#installation","text":"Isotopes can be installed with npm : npm install isotopes aws-sdk TypeScript typings are provided as part of the package, so no need to install a separate package. The aws-sdk is listed as a peer dependency, so make sure it is installed. Note that when you run Isotopes from within AWS Lambda the SDK is already installed.","title":"Installation"},{"location":"getting-started/#usage","text":"Isotopes = SimpleDB + TypeScript The following instructions are intended for usage with TypeScript. You can also use Isotopes from plain JavaScript by omitting all typings from the examples, but what would be the point? Learn TypeScript , it's awesome! First, import Isotopes into your project: import { Isotope } from \"isotopes\" Next, define a TypeScript interface for the data you want to store, e.g. a type for running a task on a cluster: export interface Task { id : string /* Unique identifier */ active : boolean /* Whether the task can be scheduled */ props : { image : string /* Docker image to use */ cpus : number /* Number of CPUs */ memory : number /* Reserved memory */ command? : string /* Command override */ }, tags : string [] /* Tags for categorization */ } Every type that is handled by Isotopes must contain a unique identifier which is used as an item name. The item name must be on the first level of the type to be stored, all other variables can be arbitrarily nested. Next, create an isotope for the type, e.g. for a SimpleDB domain named tasks : const tasks = new Isotope < Task > ({ domain : \"tasks\" , /* SimpleDB domain name */ key : \"id\" /* SimpleDB item name (primary key) */ }) Now, suppose we have the following item: const task : Task = { id : \"example\" , active : true , props : { image : \"busybox\" , cpus : 2 , memory : 2048 }, tags : [ \"TAG_1\" , \"TAG_2\" ] } We can persist, retrieve and delete items from the isotope by using a simple API, cleverly omitting all the boilerplate that is normally necessary for interfacing with SimpleDB.","title":"Usage"},{"location":"getting-started/#create-a-domain","text":"Reference for Isotope.create If the SimpleDB domain doesn't exist, create it: await isotope . create ()","title":"Create a domain"},{"location":"getting-started/#persist-an-item","text":"Reference for Isotope.put Persisting an item is as simple as: await tasks . put ( task ) // => void","title":"Persist an item"},{"location":"getting-started/#retrieve-an-item","text":"Reference for Isotope.get Retrieving an item by primary key (unique identifier, in our example id ): const task = await tasks . get ( \"example\" ) // => Task | undefined","title":"Retrieve an item"},{"location":"getting-started/#delete-an-item","text":"Reference for Isotope.delete Delete an item by primary key: await tasks . delete ( \"example\" ) // => void","title":"Delete an item"},{"location":"getting-started/#query-a-domain","text":"Reference for Isotope.select We can also build queries using a stripped-down version of the squel query builder interface: const expr = tasks . getQueryBuilder () . where ( \"`active` = ?\" , true ) . order ( \"`props.memory >= ?`\" , 2048 ) . limit ( 100 ) The query expression can then be used to perform a SELECT operation: await tasks . select ( expr )","title":"Query a domain"},{"location":"getting-started/#handling-errors","text":"All methods except getQueryBuilder return Promises, so they are best to be used with ES7's async/await and wrapped in try/catch blocks for error handling purposes: try { await tasks . put ( task ) } catch ( err ) { /* Handle error */ }","title":"Handling errors"},{"location":"license/","text":"License \u00b6 MIT License Copyright \u00a9 2018-2020 Martin Donath Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"license/#license","text":"MIT License Copyright \u00a9 2018-2020 Martin Donath Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"release-notes/","text":"Release notes \u00b6 Upgrading \u00b6 To upgrade Isotopes to the latest version, use npm : npm update isotopes Changelog \u00b6 0.5.1 _ December 26, 2018 \u00b6 Updated all dependencies to fix security vulnerabilities 0.5.0 _ August 7, 2018 \u00b6 Removed retryability implementation (AWS SDK provides it) 0.4.2 _ August 7, 2018 \u00b6 Fixed failing delete operation without attribute names 0.4.1 _ August 7, 2018 \u00b6 Added missing typings to dependencies 0.4.0 _ August 5, 2018 \u00b6 Added fault-tolerance (retryability) to all SimpleDB client requests 0.3.2 _ August 2, 2018 \u00b6 Added runtime check to Isotope.put for presence of item name Added comments to TypeScript annotations Fixed generic partial types to be too shallow 0.3.2 _ August 1, 2018 \u00b6 Added utility types for recursively making types all optional or required 0.3.1 _ July 30, 2018 \u00b6 Fixed handling of undefined values in WHERE clauses 0.3.0 _ July 30, 2018 \u00b6 Added support for domain creation and destruction Refactored result to return token value instead of function 0.2.0 _ July 29, 2018 \u00b6 Added support for multi-attribute values 0.1.1 _ July 27, 2018 \u00b6 Fixed entrypoint and typings 0.1.0 _ July 27, 2018 \u00b6 Initial release","title":"Release notes"},{"location":"release-notes/#release-notes","text":"","title":"Release notes"},{"location":"release-notes/#upgrading","text":"To upgrade Isotopes to the latest version, use npm : npm update isotopes","title":"Upgrading"},{"location":"release-notes/#changelog","text":"","title":"Changelog"},{"location":"release-notes/#051-_-december-26-2018","text":"Updated all dependencies to fix security vulnerabilities","title":"0.5.1 _ December 26, 2018"},{"location":"release-notes/#050-_-august-7-2018","text":"Removed retryability implementation (AWS SDK provides it)","title":"0.5.0 _ August 7, 2018"},{"location":"release-notes/#042-_-august-7-2018","text":"Fixed failing delete operation without attribute names","title":"0.4.2 _ August 7, 2018"},{"location":"release-notes/#041-_-august-7-2018","text":"Added missing typings to dependencies","title":"0.4.1 _ August 7, 2018"},{"location":"release-notes/#040-_-august-5-2018","text":"Added fault-tolerance (retryability) to all SimpleDB client requests","title":"0.4.0 _ August 5, 2018"},{"location":"release-notes/#032-_-august-2-2018","text":"Added runtime check to Isotope.put for presence of item name Added comments to TypeScript annotations Fixed generic partial types to be too shallow","title":"0.3.2 _ August 2, 2018"},{"location":"release-notes/#032-_-august-1-2018","text":"Added utility types for recursively making types all optional or required","title":"0.3.2 _ August 1, 2018"},{"location":"release-notes/#031-_-july-30-2018","text":"Fixed handling of undefined values in WHERE clauses","title":"0.3.1 _ July 30, 2018"},{"location":"release-notes/#030-_-july-30-2018","text":"Added support for domain creation and destruction Refactored result to return token value instead of function","title":"0.3.0 _ July 30, 2018"},{"location":"release-notes/#020-_-july-29-2018","text":"Added support for multi-attribute values","title":"0.2.0 _ July 29, 2018"},{"location":"release-notes/#011-_-july-27-2018","text":"Fixed entrypoint and typings","title":"0.1.1 _ July 27, 2018"},{"location":"release-notes/#010-_-july-27-2018","text":"Initial release","title":"0.1.0 _ July 27, 2018"},{"location":"reference/isotope/create/","text":"Isotope.create \u00b6 Create the SimpleDB domain Signature \u00b6 Isotope < T , TPut = T , TGet = T > . create () : Promise < void > Isotopes provides a thin wrapper around AWS SimpleDB domains which enables storage and retrieval of typed hierarchical data, but it won't create or destroy domains automatically. While this method will create a SimpleDB domain, it is absolutely recommended to use Terraform for creation and destruction. Parameters \u00b6 none Example \u00b6 await isotope . create ()","title":"Isotope.create"},{"location":"reference/isotope/create/#isotopecreate","text":"Create the SimpleDB domain","title":"Isotope.create"},{"location":"reference/isotope/create/#signature","text":"Isotope < T , TPut = T , TGet = T > . create () : Promise < void > Isotopes provides a thin wrapper around AWS SimpleDB domains which enables storage and retrieval of typed hierarchical data, but it won't create or destroy domains automatically. While this method will create a SimpleDB domain, it is absolutely recommended to use Terraform for creation and destruction.","title":"Signature"},{"location":"reference/isotope/create/#parameters","text":"none","title":"Parameters"},{"location":"reference/isotope/create/#example","text":"await isotope . create ()","title":"Example"},{"location":"reference/isotope/delete/","text":"Isotope.delete \u00b6 Delete an item from SimpleDB Signature \u00b6 Isotope < T , TPut = T , TGet = T > . delete ( id : string , names? : string [] ) : Promise < void > This operation is idempotent, which means that executing the same operation twice will always yield the same result. Parameters \u00b6 id Identifier \u2014 unique value used for identification (SimpleDB item name). names Attribute names \u2014 optional \u2014 a set of flattened field names that should be deleted from SimpleDB. By providing attribute names, specific fields can be deleted keeping the item alive. If this parameter is omitted, the whole item is deleted. Example \u00b6 await isotope . delete ( id )","title":"Isotope.delete"},{"location":"reference/isotope/delete/#isotopedelete","text":"Delete an item from SimpleDB","title":"Isotope.delete"},{"location":"reference/isotope/delete/#signature","text":"Isotope < T , TPut = T , TGet = T > . delete ( id : string , names? : string [] ) : Promise < void > This operation is idempotent, which means that executing the same operation twice will always yield the same result.","title":"Signature"},{"location":"reference/isotope/delete/#parameters","text":"id Identifier \u2014 unique value used for identification (SimpleDB item name). names Attribute names \u2014 optional \u2014 a set of flattened field names that should be deleted from SimpleDB. By providing attribute names, specific fields can be deleted keeping the item alive. If this parameter is omitted, the whole item is deleted.","title":"Parameters"},{"location":"reference/isotope/delete/#example","text":"await isotope . delete ( id )","title":"Example"},{"location":"reference/isotope/destroy/","text":"Isotope.destroy \u00b6 Destroy the SimpleDB domain Signature \u00b6 Isotope < T , TPut = T , TGet = T > . destroy () : Promise < void > Isotopes provides a thin wrapper around AWS SimpleDB domains which enables storage and retrieval of typed hierarchical data, but it won't create or destroy domains automatically. While this method will create a SimpleDB domain, it is absolutely recommended to use Terraform for creation and destruction. Parameters \u00b6 none Example \u00b6 await isotope . destroy ()","title":"Isotope.destroy"},{"location":"reference/isotope/destroy/#isotopedestroy","text":"Destroy the SimpleDB domain","title":"Isotope.destroy"},{"location":"reference/isotope/destroy/#signature","text":"Isotope < T , TPut = T , TGet = T > . destroy () : Promise < void > Isotopes provides a thin wrapper around AWS SimpleDB domains which enables storage and retrieval of typed hierarchical data, but it won't create or destroy domains automatically. While this method will create a SimpleDB domain, it is absolutely recommended to use Terraform for creation and destruction.","title":"Signature"},{"location":"reference/isotope/destroy/#parameters","text":"none","title":"Parameters"},{"location":"reference/isotope/destroy/#example","text":"await isotope . destroy ()","title":"Example"},{"location":"reference/isotope/get-query-builder/","text":"Isotope.getQueryBuilder \u00b6 Create an SQL query expression builder Signature \u00b6 Isotope < T , TPut = T , TGet = T > . getQueryBuilder () : IsotopeSelect This method returns an object of type IsotopeSelect . Parameters \u00b6 none Example \u00b6 const expr = isotope . getQueryBuilder ()","title":"Isotope.getQueryBuilder"},{"location":"reference/isotope/get-query-builder/#isotopegetquerybuilder","text":"Create an SQL query expression builder","title":"Isotope.getQueryBuilder"},{"location":"reference/isotope/get-query-builder/#signature","text":"Isotope < T , TPut = T , TGet = T > . getQueryBuilder () : IsotopeSelect This method returns an object of type IsotopeSelect .","title":"Signature"},{"location":"reference/isotope/get-query-builder/#parameters","text":"none","title":"Parameters"},{"location":"reference/isotope/get-query-builder/#example","text":"const expr = isotope . getQueryBuilder ()","title":"Example"},{"location":"reference/isotope/get/","text":"Isotope.get \u00b6 Retrieve an item from SimpleDB Signature \u00b6 Isotope < T , TPut = T , TGet = T > . get ( id : string , names? : string [] ) : Promise < TGet | DeepPartial < TGet > | undefined > Note that this method may return partial items if they are stored as such in SimpleDB, so to obtain type safety with TypeScript, you have to make sure that all items define all required fields before retrieving them from SimpleDB. If unsure, it's best to configure Isotopes with Partial<T> or DeepPartial<T> for TGet , see this section . Parameters \u00b6 id Identifier \u2014 unique value used for identification (SimpleDB item name). names Attribute names \u2014 optional \u2014 a set of flattened field names that should be retrieved from SimpleDB. If this parameter is omitted SimpleDB will return all attributes for a given item. If this parameter is specified, the Promise will resolve with a DeepPartial<TGet> type. Example \u00b6 const item = await isotope . get ( id )","title":"Isotope.get"},{"location":"reference/isotope/get/#isotopeget","text":"Retrieve an item from SimpleDB","title":"Isotope.get"},{"location":"reference/isotope/get/#signature","text":"Isotope < T , TPut = T , TGet = T > . get ( id : string , names? : string [] ) : Promise < TGet | DeepPartial < TGet > | undefined > Note that this method may return partial items if they are stored as such in SimpleDB, so to obtain type safety with TypeScript, you have to make sure that all items define all required fields before retrieving them from SimpleDB. If unsure, it's best to configure Isotopes with Partial<T> or DeepPartial<T> for TGet , see this section .","title":"Signature"},{"location":"reference/isotope/get/#parameters","text":"id Identifier \u2014 unique value used for identification (SimpleDB item name). names Attribute names \u2014 optional \u2014 a set of flattened field names that should be retrieved from SimpleDB. If this parameter is omitted SimpleDB will return all attributes for a given item. If this parameter is specified, the Promise will resolve with a DeepPartial<TGet> type.","title":"Parameters"},{"location":"reference/isotope/get/#example","text":"const item = await isotope . get ( id )","title":"Example"},{"location":"reference/isotope/new/","text":"Isotope \u00b6 Create a SimpleDB domain client Signature \u00b6 new Isotope < T , [ TPut , [ TGet ]] > ( options : IsotopeOptions < T > ) : Isotope < T > Initializes an isotope using the given options of which domain and key are mandatory. The format option can be used to define the serialization method that is used for the values before writing them to SimpleDB. The client option enables configuration of the SimpleDB client. Typings \u00b6 By default, Isotopes forces only valid entries to be written to SimpleDB which means that all non-optional fields need to be defined in the payload (otherwise the TypeScript compiler will moan). However, SimpleDB allows reading and writing of partial attribute values, so it might be desirable in some cases to loosen that restriction and allow partial reads and writes. Isotopes allows both configurations through simple generic typing. class Isotope < T extends {}, /* Data type */ TPut extends DeepPartial < T > = T , /* Data type expected by PUT operation */ TGet extends DeepPartial < T > = TPut /* Data type returned by GET operation */ > {} The first type argument is mandatory and defines the base type. The second and third type arguments can be used to specify what exact types PUT and GET operations return but normally they are equal to the base type. Allow complete values only: new Isotope < T > (...) Allow partial values in PUT and GET operations: new Isotope < T , DeepPartial < T >> (...) Allow partial values in GET operations only: new Isotope < T , T , DeepPartial < T >> (...) The DeepPartial type is exported by Isotopes . Parameters \u00b6 options.domain SimpleDB domain name options.key SimpleDB item name (primary key) options.format.encoding Encoding method for values \u2014 optional , default: \"json\" \u2014 please see this section to learn how the available encoding methods \"json\" and \"text\" determine how values are written to SimpleDB. options.format.multiple Write multi-attribute values for arrays \u2014 optional , default: true \u2014 please see this section to learn how this will impact object flattening and persistence within SimpleDB. options.client.consistent Use consistent reads for GET and SELECT operations \u2014 optional , default: false \u2014 see the official documentation for further information on consistency within SimpleDB. Example \u00b6 const isotope = new Isotope < T > ({ domain : \"<domain>\" , key : \"<keyof T>\" , /* Optional: format options */ format : { encoding : \"json\" , multiple : true }, /* Optional: SimpleDB client options */ client : { consistent : false } })","title":"new Isotope"},{"location":"reference/isotope/new/#isotope","text":"Create a SimpleDB domain client","title":"Isotope"},{"location":"reference/isotope/new/#signature","text":"new Isotope < T , [ TPut , [ TGet ]] > ( options : IsotopeOptions < T > ) : Isotope < T > Initializes an isotope using the given options of which domain and key are mandatory. The format option can be used to define the serialization method that is used for the values before writing them to SimpleDB. The client option enables configuration of the SimpleDB client.","title":"Signature"},{"location":"reference/isotope/new/#typings","text":"By default, Isotopes forces only valid entries to be written to SimpleDB which means that all non-optional fields need to be defined in the payload (otherwise the TypeScript compiler will moan). However, SimpleDB allows reading and writing of partial attribute values, so it might be desirable in some cases to loosen that restriction and allow partial reads and writes. Isotopes allows both configurations through simple generic typing. class Isotope < T extends {}, /* Data type */ TPut extends DeepPartial < T > = T , /* Data type expected by PUT operation */ TGet extends DeepPartial < T > = TPut /* Data type returned by GET operation */ > {} The first type argument is mandatory and defines the base type. The second and third type arguments can be used to specify what exact types PUT and GET operations return but normally they are equal to the base type. Allow complete values only: new Isotope < T > (...) Allow partial values in PUT and GET operations: new Isotope < T , DeepPartial < T >> (...) Allow partial values in GET operations only: new Isotope < T , T , DeepPartial < T >> (...) The DeepPartial type is exported by Isotopes .","title":"Typings"},{"location":"reference/isotope/new/#parameters","text":"options.domain SimpleDB domain name options.key SimpleDB item name (primary key) options.format.encoding Encoding method for values \u2014 optional , default: \"json\" \u2014 please see this section to learn how the available encoding methods \"json\" and \"text\" determine how values are written to SimpleDB. options.format.multiple Write multi-attribute values for arrays \u2014 optional , default: true \u2014 please see this section to learn how this will impact object flattening and persistence within SimpleDB. options.client.consistent Use consistent reads for GET and SELECT operations \u2014 optional , default: false \u2014 see the official documentation for further information on consistency within SimpleDB.","title":"Parameters"},{"location":"reference/isotope/new/#example","text":"const isotope = new Isotope < T > ({ domain : \"<domain>\" , key : \"<keyof T>\" , /* Optional: format options */ format : { encoding : \"json\" , multiple : true }, /* Optional: SimpleDB client options */ client : { consistent : false } })","title":"Example"},{"location":"reference/isotope/put/","text":"Isotope.put \u00b6 Persist an item within SimpleDB Signature \u00b6 Isotope < T , TPut = T , TGet = T > . put ( data : TPut ) : Promise < void > Parameters \u00b6 data Data to be persisted \u2014 by default, partial data will trigger TypeScript errors due to the specified typings. In order to write partial data, Isotopes must be configured with Partial<T> or DeepPartial<T> for TPut , see this section . Before delegating to SimpleDB, the keys of the data object are flattened and the values are encoded according to the method specified in options.format.encoding during initialization of the isotope. Example \u00b6 await isotope . put ( data )","title":"Isotope.put"},{"location":"reference/isotope/put/#isotopeput","text":"Persist an item within SimpleDB","title":"Isotope.put"},{"location":"reference/isotope/put/#signature","text":"Isotope < T , TPut = T , TGet = T > . put ( data : TPut ) : Promise < void >","title":"Signature"},{"location":"reference/isotope/put/#parameters","text":"data Data to be persisted \u2014 by default, partial data will trigger TypeScript errors due to the specified typings. In order to write partial data, Isotopes must be configured with Partial<T> or DeepPartial<T> for TPut , see this section . Before delegating to SimpleDB, the keys of the data object are flattened and the values are encoded according to the method specified in options.format.encoding during initialization of the isotope.","title":"Parameters"},{"location":"reference/isotope/put/#example","text":"await isotope . put ( data )","title":"Example"},{"location":"reference/isotope/select/","text":"Isotope.select \u00b6 Retrieve a set of items from SimpleDB matching a given SQL query expression Signature \u00b6 Isotope < T , TPut = T , TGet = T > . select < TSelect extends TGet = TGet > ( expr : IsotopeSelect < T > | string , prev? : string ) : Promise < IsotopeResult < TSelect >> By default, SELECT operations are assumed to return the same type as GET . As this may differ by usecase (depending on the specific SQL query), it may be overridden on a per-query basis. Parameters \u00b6 expr Query builder or string containing a SQL query expression \u2014 the easiest way to construct SQL queries that can be understood by SimpleDB is using the query builder which is implemented using squel . A query builder can be obtained using getQueryBuilder() . prev Pagination token, optional \u2014 a SELECT operation returns a pagination token if there are more results to fetch, as SimpleDB uses token-based pagination. This token can then be passed to the same method using the same SQL query expression to obtain the next page of items. Example \u00b6 let prev do { const { items , next } = await isotope . select ( expr , prev ) items . map ( console . log ) prev = next } while ( prev )","title":"Isotope.select"},{"location":"reference/isotope/select/#isotopeselect","text":"Retrieve a set of items from SimpleDB matching a given SQL query expression","title":"Isotope.select"},{"location":"reference/isotope/select/#signature","text":"Isotope < T , TPut = T , TGet = T > . select < TSelect extends TGet = TGet > ( expr : IsotopeSelect < T > | string , prev? : string ) : Promise < IsotopeResult < TSelect >> By default, SELECT operations are assumed to return the same type as GET . As this may differ by usecase (depending on the specific SQL query), it may be overridden on a per-query basis.","title":"Signature"},{"location":"reference/isotope/select/#parameters","text":"expr Query builder or string containing a SQL query expression \u2014 the easiest way to construct SQL queries that can be understood by SimpleDB is using the query builder which is implemented using squel . A query builder can be obtained using getQueryBuilder() . prev Pagination token, optional \u2014 a SELECT operation returns a pagination token if there are more results to fetch, as SimpleDB uses token-based pagination. This token can then be passed to the same method using the same SQL query expression to obtain the next page of items.","title":"Parameters"},{"location":"reference/isotope/select/#example","text":"let prev do { const { items , next } = await isotope . select ( expr , prev ) items . map ( console . log ) prev = next } while ( prev )","title":"Example"},{"location":"reference/isotope-select/limit/","text":"IsotopeSelect.limit \u00b6 Add an LIMIT clause to a SQL query expression Signature \u00b6 IsotopeSelect < T > . limit ( count : number ) : this Parameters \u00b6 count Number of records. Example \u00b6 // SELECT * FROM `domain` LIMIT 100 isotope . getQueryBuilder () . limit ( 100 ) . toString ()","title":"IsotopeSelect.limit"},{"location":"reference/isotope-select/limit/#isotopeselectlimit","text":"Add an LIMIT clause to a SQL query expression","title":"IsotopeSelect.limit"},{"location":"reference/isotope-select/limit/#signature","text":"IsotopeSelect < T > . limit ( count : number ) : this","title":"Signature"},{"location":"reference/isotope-select/limit/#parameters","text":"count Number of records.","title":"Parameters"},{"location":"reference/isotope-select/limit/#example","text":"// SELECT * FROM `domain` LIMIT 100 isotope . getQueryBuilder () . limit ( 100 ) . toString ()","title":"Example"},{"location":"reference/isotope-select/new/","text":"IsotopeSelect \u00b6 Create a SQL query expression builder Signature \u00b6 new IsotopeSelect < T ] > ( options : IsotopeOptions < T > , ) : Isotope < T > The query builder should not be instantiated manually. It's better to use Isotope.getQueryBuilder because the isotope will pass its options to the constructor. Parameters \u00b6 options Same as the options passed to the isotope constructor, see here . Example \u00b6 const expr = isotope . getQueryBuilder ()","title":"new IsotopeSelect"},{"location":"reference/isotope-select/new/#isotopeselect","text":"Create a SQL query expression builder","title":"IsotopeSelect"},{"location":"reference/isotope-select/new/#signature","text":"new IsotopeSelect < T ] > ( options : IsotopeOptions < T > , ) : Isotope < T > The query builder should not be instantiated manually. It's better to use Isotope.getQueryBuilder because the isotope will pass its options to the constructor.","title":"Signature"},{"location":"reference/isotope-select/new/#parameters","text":"options Same as the options passed to the isotope constructor, see here .","title":"Parameters"},{"location":"reference/isotope-select/new/#example","text":"const expr = isotope . getQueryBuilder ()","title":"Example"},{"location":"reference/isotope-select/order/","text":"IsotopeSelect.order \u00b6 Add an ORDER BY clause to a SQL query expression Signature \u00b6 IsotopeSelect < T > . order ( field : string , direction ?: \"asc\" | \"desc\" ) : this Parameters \u00b6 field Sort field. direction Sort direction \u2014 optional , default: \"asc\" . Example \u00b6 // SELECT * FROM `domain` ORDER BY `key` ASC isotope . getQueryBuilder () . order ( \"`key`\" ) . toString ()","title":"IsotopeSelect.order"},{"location":"reference/isotope-select/order/#isotopeselectorder","text":"Add an ORDER BY clause to a SQL query expression","title":"IsotopeSelect.order"},{"location":"reference/isotope-select/order/#signature","text":"IsotopeSelect < T > . order ( field : string , direction ?: \"asc\" | \"desc\" ) : this","title":"Signature"},{"location":"reference/isotope-select/order/#parameters","text":"field Sort field. direction Sort direction \u2014 optional , default: \"asc\" .","title":"Parameters"},{"location":"reference/isotope-select/order/#example","text":"// SELECT * FROM `domain` ORDER BY `key` ASC isotope . getQueryBuilder () . order ( \"`key`\" ) . toString ()","title":"Example"},{"location":"reference/isotope-select/where/","text":"IsotopeSelect.where \u00b6 Add a WHERE clause to a SQL query expression Signature \u00b6 IsotopeSelect < T > . where ( condition : string , ... args : any [] ) : this Parameters \u00b6 condition Condition expression \u2014 an expression can contain various placeholders, namely ? which can be passed as variadic arguments. See the official AWS documentation on the SimpleDB query language in order to learn about the types of expressions that can be used in SQL queries or see this section for some usage examples. A brief overview: Comparison operators Simple queries Range queries Queries on attributes with multiple values Multiple attribute queries ...args Placeholder arguments which are replaced in the condition expression \u2014 note that string values are auto-quoted if the encoding is set to \"json\" . If the condition contains a LIKE expression, string values must include a % sign which is not quoted, so JSON values can also be searched. Example \u00b6 = \u00b6 JSON encoding // SELECT * FROM `domain` WHERE (`key` = '\"value\"') isotope . getQueryBuilder () . where ( \"`key` = ?\" , \"value\" ) . toString () Text encoding // SELECT * FROM `domain` WHERE (`key` = 'value') isotope . getQueryBuilder () . where ( \"`key` = ?\" , \"value\" ) . toString () LIKE \u00b6 JSON encoding // SELECT * FROM `domain` WHERE (`key` LIKE '\"value%') isotope . getQueryBuilder () . where ( \"`key` LIKE ?\" , \"value%\" ) . toString () Text encoding // SELECT * FROM `domain` WHERE (`key` LIKE 'value%') isotope . getQueryBuilder () . where ( \"`key` LIKE ?\" , \"value%\" ) . toString () AND \u00b6 JSON encoding // SELECT * FROM `domain` WHERE (`key` >= '1') AND (`key` <= '2') isotope . getQueryBuilder () . where ( \"`key` >= ?\" , 1 ) . where ( \"`key` <= ?\" , 2 ) . toString () Text encoding // SELECT * FROM `domain` WHERE (`key` >= '1') AND (`key` <= '2') isotope . getQueryBuilder () . where ( \"`key` >= ?\" , 1 ) . where ( \"`key` <= ?\" , 2 ) . toString () OR \u00b6 JSON encoding // SELECT * FROM `domain` WHERE (`key` = '1' OR `key` = '2') isotope . getQueryBuilder () . where ( \"`key` = ? OR `key` = ?\" , 1 , 2 ) . toString () Text encoding // SELECT * FROM `domain` WHERE (`key` = '1' OR `key` = '2') isotope . getQueryBuilder () . where ( \"`key` = ? OR `key` = ?\" , 1 , 2 ) . toString ()","title":"IsotopeSelect.where"},{"location":"reference/isotope-select/where/#isotopeselectwhere","text":"Add a WHERE clause to a SQL query expression","title":"IsotopeSelect.where"},{"location":"reference/isotope-select/where/#signature","text":"IsotopeSelect < T > . where ( condition : string , ... args : any [] ) : this","title":"Signature"},{"location":"reference/isotope-select/where/#parameters","text":"condition Condition expression \u2014 an expression can contain various placeholders, namely ? which can be passed as variadic arguments. See the official AWS documentation on the SimpleDB query language in order to learn about the types of expressions that can be used in SQL queries or see this section for some usage examples. A brief overview: Comparison operators Simple queries Range queries Queries on attributes with multiple values Multiple attribute queries ...args Placeholder arguments which are replaced in the condition expression \u2014 note that string values are auto-quoted if the encoding is set to \"json\" . If the condition contains a LIKE expression, string values must include a % sign which is not quoted, so JSON values can also be searched.","title":"Parameters"},{"location":"reference/isotope-select/where/#example","text":"","title":"Example"},{"location":"reference/isotope-select/where/#_1","text":"JSON encoding // SELECT * FROM `domain` WHERE (`key` = '\"value\"') isotope . getQueryBuilder () . where ( \"`key` = ?\" , \"value\" ) . toString () Text encoding // SELECT * FROM `domain` WHERE (`key` = 'value') isotope . getQueryBuilder () . where ( \"`key` = ?\" , \"value\" ) . toString ()","title":"="},{"location":"reference/isotope-select/where/#like","text":"JSON encoding // SELECT * FROM `domain` WHERE (`key` LIKE '\"value%') isotope . getQueryBuilder () . where ( \"`key` LIKE ?\" , \"value%\" ) . toString () Text encoding // SELECT * FROM `domain` WHERE (`key` LIKE 'value%') isotope . getQueryBuilder () . where ( \"`key` LIKE ?\" , \"value%\" ) . toString ()","title":"LIKE"},{"location":"reference/isotope-select/where/#and","text":"JSON encoding // SELECT * FROM `domain` WHERE (`key` >= '1') AND (`key` <= '2') isotope . getQueryBuilder () . where ( \"`key` >= ?\" , 1 ) . where ( \"`key` <= ?\" , 2 ) . toString () Text encoding // SELECT * FROM `domain` WHERE (`key` >= '1') AND (`key` <= '2') isotope . getQueryBuilder () . where ( \"`key` >= ?\" , 1 ) . where ( \"`key` <= ?\" , 2 ) . toString ()","title":"AND"},{"location":"reference/isotope-select/where/#or","text":"JSON encoding // SELECT * FROM `domain` WHERE (`key` = '1' OR `key` = '2') isotope . getQueryBuilder () . where ( \"`key` = ? OR `key` = ?\" , 1 , 2 ) . toString () Text encoding // SELECT * FROM `domain` WHERE (`key` = '1' OR `key` = '2') isotope . getQueryBuilder () . where ( \"`key` = ? OR `key` = ?\" , 1 , 2 ) . toString ()","title":"OR"}]}